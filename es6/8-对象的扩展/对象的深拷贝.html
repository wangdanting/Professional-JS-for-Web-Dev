<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

<script>
  const s = Symbol('s');
  const test = {
    num: 0,
    str: '',
    boolean: true,
    unf: undefined,
    nul: null,
    obj: {
      name: '我是一个对象',
      id: 1,
      innerObj: {
        name: '我是对象的对象',
        id: 1.1
      }
    },
    arr: [0, 1, 2],
    date: new Date('1996/03/03'),
    reg: new RegExp(/我是一个正则/ig),
    err: new Error('我是一个错误'),
    [s]: '我的key是Symbol',
    noEnumerable: '我是手动设置的不可枚举属性',
    func() {
      console.log('我是一个函数');
    },
    get num1() {
      return this.num;
    },
    set num1(val) {
      this.num = val
    }
  };

  Object.defineProperty(test, 'noEnumerable', {enumerable: false});
  // 创建一个新对象，使用现有的对象来提供新创建的对象的_proto_
  const testChild = Object.create(test);

  function isObject(o) {
    return (typeof o === 'object') && o !==null;
  }

  // *****序列化反序列化法*****
  //继承的可枚举属性 (no)
  //自身的可枚举属性 (yes)
  //自身的不可枚举属性 (no)
  //自身的Symbol属性 (no)
  //正确拷贝自身的方法 (no)
  //正确拷贝自身的特殊构造函数 (no)
  const test1 = JSON.parse(JSON.stringify(test));
  const test1Prop = JSON.parse(JSON.stringify(testChild))

  // ******迭代递归法*******

  // *****普通for...in法*****
  function deepCopy(obj) {
    let temp = Array.isArray(obj) ? [] : {};
    for(let key in obj) {
      temp[key] = isObject(obj[key]) ? deepCopy(obj[key]) : obj[key];
    }
    return temp;
  }

  const test2 = deepCopy(test);
  const test2Prop = deepCopy(testChild);
  //不能拷贝不可枚举属性
  //set get

  //new Date类型不能正确拷贝
  test.date; //Sun Mar 03 1996 00:00:00 GMT+0800 (中国标准时间)
  test2.date; //{}

  // new RegExp类型不能正确拷贝
  test.reg; // /我是一个正则/gi
  test1.reg; // {}

  // new Error类型不能正确拷贝
  test.err; // Error: 我是一个错误
  test1.err; // {}

  //Symbol类型的属性不能拷贝

  // *****迭代递归法 Reflect法*****
  function deepCopy1(obj) {
    let temp = Array.isArray(obj) ? [] : {};
    Reflect.ownKeys(obj).forEach(key => {
      temp[key] = isObject(obj[key]) ? deepCopy1(obj[key]) : obj[key];
    })
    return temp;
  }

  const test3 = deepCopy1(test);
  const test3Prop = deepCopy1(testChild);
  // 不能拷贝原型上的属性

  // 不能拷贝不可枚举属性
  //set get

  //new Date类型不能正确拷贝
  test.date; //Sun Mar 03 1996 00:00:00 GMT+0800 (中国标准时间)
  test3.date; //{}

  // new RegExp类型不能正确拷贝
  test.reg; // /我是一个正则/gi
  test3.reg; // {lastIndex: 0}

  // new Error类型不能正确拷贝
  test.err; // Error: 我是一个错误
  test3.err; // {stack: "Error: 我是一个错误↵    at file:///Users/wangdanting/Lea…A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D.html:28:10", message: "我是一个错误"}

  // *****迭代递归法 Object.getPrototypeOf法*****
  function deepCopy2(obj) {
    let temp = Array.isArray(obj) ? [] : {};

    let cloneObj = Object.create(
      Object.getPrototypeOf(obj),
      Object.getOwnPropertyDescriptors(obj)
    )
 
    for(let key in obj) {
      cloneObj[key] = isObject(obj[key]) ? deepCopy2(obj[key]) : obj[key];
    }
    return cloneObj;
  }

  const test4 = deepCopy2(test);
  const test4Prop = deepCopy2(testChild);

  //new Date类型不能正确拷贝
  // new RegExp类型不能正确拷贝
  // new Error类型不能正确拷贝
  
</script>
</body>
</html>